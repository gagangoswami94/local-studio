# Validation Pipeline Integration

## Overview

The validation pipeline is now fully integrated into the bundle generation workflow. All bundles generated by the AgentOrchestrator go through comprehensive quality checks via the Release Gate before being cryptographically signed and returned.

## Architecture

```
Generate Phase → Validate Phase (ReleaseGate) → Sign Bundle → Return
                      ↓
           ┌──────────┴──────────┐
           │   6 Quality Checks   │
           ├──────────────────────┤
           │ 1. SyntaxCheck      │ (blocker)
           │ 2. DependencyCheck  │ (blocker)
           │ 3. SchemaCheck      │ (blocker)
           │ 4. TestCoverageCheck│ (blocker)
           │ 5. SecurityCheck    │ (warning)
           │ 6. MigrationCheck   │ (blocker)
           └─────────────────────┘
                      ↓
           ┌──────────┴──────────┐
           │   passed = true?    │
           └──────────┬──────────┘
                 yes  │  no
                      │
         ┌────────────┴────────────┐
         ↓                         ↓
    Sign Bundle              Block Release
    Return Success          Return Failure
```

## Components

### 1. ReleaseGate (src/agent/validation/ReleaseGate.js)

**Purpose:** Orchestrates all validation checks

**Key Methods:**
- `runAll(bundle)` - Runs all checks, returns { passed, blockers, warnings, report }
- `runCheck(checkName, bundle)` - Runs a specific check
- `generateSummary(result)` - Generates human-readable validation report

**Configuration:**
```javascript
new ReleaseGate({
  logger: logger,
  coverageThreshold: 80  // Default test coverage threshold
})
```

### 2. Validation Checks

All checks extend `BaseCheck` and implement the `run(bundle)` method.

#### SyntaxCheck (blocker)
- Validates JavaScript/TypeScript/JSON/CSS syntax
- Uses Babel parser for JS/TS
- Blocks release on syntax errors

#### DependencyCheck (blocker)
- Verifies all imports can be resolved
- Checks against package.json and workspace files
- Detects missing dependencies

#### SchemaCheck (blocker)
- Validates bundle structure
- Ensures required fields (bundle_id, bundle_type, created_at, files)
- Validates appSpec and plan schemas if present

#### TestCoverageCheck (blocker)
- Calculates test coverage percentage
- Configurable threshold (default: 80%)
- Only checks code files (js/jsx/ts/tsx/py/rb/go/java)
- Excludes config and test files

#### SecurityCheck (warning)
- Scans for hardcoded secrets (API keys, passwords, AWS keys)
- Detects dangerous patterns (eval(), innerHTML, etc.)
- Checks for SQL injection risks
- **Warning level** - doesn't block release

#### MigrationReversibilityCheck (blocker)
- Verifies all migrations have reverse SQL
- Checks that reverse operations undo forward operations
- Supports: CREATE/DROP TABLE, ADD/DROP COLUMN, CREATE/DROP INDEX

### 3. BundleSigner (src/security/BundleSigner.js)

**Purpose:** Cryptographic signing of validated bundles

**Key Features:**
- RSA-2048 signing with SHA-256 hash
- Deterministic JSON serialization (sorted keys)
- Automatic key generation on first run
- Keys stored in `keys/` directory (excluded from git)

**Signature Structure:**
```javascript
{
  algorithm: 'RSA-SHA256',
  value: '<base64-encoded-signature>',
  keyId: 'local-studio-dev',
  timestamp: '2026-01-31T12:00:00.000Z'
}
```

**Key Methods:**
- `initialize()` - Load or generate keypair
- `signBundle(bundle)` - Sign bundle and return signed bundle
- `verifyBundle(signedBundle)` - Verify signature is valid

### 4. AgentOrchestrator Integration

**Updated Methods:**

`_initializeComponents()` - Now initializes ReleaseGate and BundleSigner:
```javascript
// Release Gate (validation)
this.releaseGate = new ReleaseGate({
  logger: this.logger,
  coverageThreshold: this.config.coverageThreshold || 80
});

// Bundle Signer
this.bundleSigner = new BundleSigner({
  logger: this.logger,
  keysPath: this.config.keysPath || './keys'
});
```

`initialize()` - Async initialization (generates/loads keys):
```javascript
async initialize() {
  if (this._initialized) return;
  await this.bundleSigner.initialize();
  this._initialized = true;
}
```

`_validatePhase(bundle)` - Runs Release Gate and signs bundle:
```javascript
async _validatePhase(bundle) {
  // Run all validation checks
  const gateResult = await this.releaseGate.runAll(bundle);

  if (gateResult.passed) {
    // Sign bundle after successful validation
    const signedBundle = this.bundleSigner.signBundle(bundle);

    return {
      valid: true,
      passed: true,
      signedBundle,
      report: gateResult.report,
      warnings: gateResult.warnings,
      blockers: []
    };
  } else {
    // Return validation failure (don't sign)
    return {
      valid: false,
      passed: false,
      signedBundle: null,
      blockers: gateResult.blockers,
      warnings: gateResult.warnings,
      summary: this.releaseGate.generateSummary(gateResult)
    };
  }
}
```

`executeBundleMode()` - Updated to handle validation failures:
```javascript
async executeBundleMode(request) {
  // ... generate bundle ...

  // Validate (includes signing if passed)
  const validation = await this._executePhase('validate', taskId, async () => {
    return await this._validatePhase(bundle);
  });

  // Check if validation passed
  if (!validation.passed) {
    // Mark task as failed, return error
    return {
      success: false,
      error: 'Bundle validation failed',
      bundle,
      validation
    };
  }

  // Return signed bundle
  return {
    success: true,
    bundle: validation.signedBundle,
    validation
  };
}
```

## Validation Flow

### 1. Bundle Generation
```
User Request → AgentOrchestrator.executeBundleMode()
  → Analyze Phase
  → Plan Phase
  → Generate Phase (creates unsigned bundle)
```

### 2. Validation Phase
```
Unsigned Bundle → ReleaseGate.runAll()
  → Run 6 validation checks in sequence
  → Collect blockers (failed blocker-level checks)
  → Collect warnings (failed warning-level checks)
  → Return { passed: blockers.length === 0, blockers, warnings, report }
```

### 3. Decision Point
```
passed === true?
  YES → BundleSigner.signBundle()
        → Add cryptographic signature
        → Return signed bundle

  NO  → Generate summary report
       → Return validation failure
       → Mark task as failed
```

## Error Handling

### Validation Failures (Blockers)

When blockers exist, the bundle is NOT signed and the task fails:

```javascript
{
  success: false,
  error: 'Bundle validation failed',
  bundle: <unsigned-bundle>,
  validation: {
    passed: false,
    blockers: [
      {
        check: 'SyntaxCheck',
        message: 'Syntax error in src/app.js',
        details: { line: 42, column: 10, error: '...' }
      }
    ],
    warnings: [...],
    summary: <human-readable-report>
  }
}
```

### Validation Success with Warnings

Warnings don't block release, but are included in the response:

```javascript
{
  success: true,
  bundle: <signed-bundle>,
  validation: {
    passed: true,
    blockers: [],
    warnings: [
      {
        check: 'SecurityCheck',
        message: 'Found 2 security issue(s)',
        details: { ... }
      }
    ]
  }
}
```

## Testing

### Unit Tests

**Release Gate Tests** (`tests/validation/test-release-gate.js`):
- 10 tests covering all validation checks
- Tests blocker vs warning behavior
- Tests summary generation
- Tests individual check execution

**Results:** All 10 tests passing ✓

### Integration Tests

**Pipeline Tests** (`tests/integration/test-validation-pipeline.js`):
- 8 tests covering complete pipeline flow
- Tests valid bundle passes and gets signed
- Tests invalid bundles are blocked
- Tests security warnings don't block
- Tests signature verification
- Tests component initialization

**Results:** All 8 tests passing ✓

## Configuration

### Coverage Threshold

```javascript
const orchestrator = new AgentOrchestrator({
  coverageThreshold: 80  // Require 80% test coverage
});
```

### Keys Path

```javascript
const orchestrator = new AgentOrchestrator({
  keysPath: './keys'  // Where to store/load signing keys
});
```

### Custom Checks

```javascript
// Add custom validation check
orchestrator.releaseGate.addCheck({
  name: 'CustomCheck',
  level: 'blocker',
  run: async (bundle) => {
    // Custom validation logic
    return { passed: true, message: 'OK', details: {} };
  }
});

// Remove a check
orchestrator.releaseGate.removeCheck('SecurityCheck');
```

## Security Considerations

1. **Private Key Protection**
   - Keys stored in `keys/` directory
   - `keys/` is excluded from git (in .gitignore)
   - Private key has 0600 permissions (Unix)

2. **Signature Verification**
   - Desktop app verifies signatures before executing bundles
   - Uses Web Crypto API for client-side verification
   - Embedded public key at build time

3. **Deterministic Serialization**
   - JSON keys sorted alphabetically
   - Ensures same bundle always produces same signature
   - Prevents signature variations from key ordering

## Performance

- **ReleaseGate:** ~10-50ms per validation (no LLM calls)
- **Bundle Signing:** ~50-100ms (RSA-2048 operation)
- **Total Overhead:** ~100-150ms added to generation pipeline

No LLM tokens are used for validation, keeping costs low.

## Future Enhancements

1. **Additional Checks**
   - Performance check (bundle size limits)
   - License compliance check
   - Breaking change detection
   - API compatibility check

2. **Configurable Thresholds**
   - Per-project coverage thresholds
   - Severity levels for security issues
   - Custom rules per stack

3. **Integration with CI/CD**
   - Export validation reports
   - Fail builds on blockers
   - Collect metrics over time

4. **Caching**
   - Cache validation results per file
   - Only re-validate changed files
   - Speed up incremental builds

## API Reference

### ReleaseGate

```javascript
const gate = new ReleaseGate({ logger, coverageThreshold: 80 });

// Run all checks
const result = await gate.runAll(bundle);
// Returns: { passed, blockers, warnings, report }

// Run specific check
const syntaxResult = await gate.runCheck('SyntaxCheck', bundle);

// Get available checks
const checks = gate.getChecks();
// Returns: [{ name: 'SyntaxCheck', level: 'blocker' }, ...]

// Generate summary
const summary = gate.generateSummary(result);
// Returns: human-readable markdown report
```

### BundleSigner

```javascript
const signer = new BundleSigner({ logger, keysPath: './keys' });

// Initialize (load or generate keys)
await signer.initialize();

// Sign bundle
const signedBundle = signer.signBundle(bundle);

// Verify signature
const isValid = signer.verifyBundle(signedBundle);
```

### AgentOrchestrator

```javascript
const orchestrator = new AgentOrchestrator({
  tokenBudget: 100000,
  coverageThreshold: 80,
  keysPath: './keys'
});

// Initialize async components
await orchestrator.initialize();

// Execute bundle mode (includes validation + signing)
const result = await orchestrator.executeBundleMode({
  message: 'Add user authentication',
  context: [...],
  appSpec: {...}
});

// Check result
if (result.success) {
  const signedBundle = result.bundle;
  const validation = result.validation;
} else {
  const blockers = result.validation.blockers;
  console.log(result.validation.summary);
}
```

## Conclusion

The validation pipeline is now fully integrated, providing:

- ✅ Comprehensive quality checks (syntax, dependencies, schema, coverage, security, migrations)
- ✅ Cryptographic bundle signing with RSA-2048
- ✅ Blocker vs warning distinction
- ✅ Human-readable validation reports
- ✅ Zero LLM tokens used for validation
- ✅ 18/18 tests passing (10 unit + 8 integration)

All bundles are now validated and signed before being sent to the desktop app for execution.
